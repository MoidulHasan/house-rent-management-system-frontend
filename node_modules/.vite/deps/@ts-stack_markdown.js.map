{
  "version": 3,
  "sources": ["../../@ts-stack/projects/markdown/src/extend-regexp.ts", "../../@ts-stack/projects/markdown/src/helpers.ts", "../../@ts-stack/projects/markdown/src/interfaces.ts", "../../@ts-stack/projects/markdown/src/renderer.ts", "../../@ts-stack/projects/markdown/src/inline-lexer.ts", "../../@ts-stack/projects/markdown/src/parser.ts", "../../@ts-stack/projects/markdown/src/marked.ts", "../../@ts-stack/projects/markdown/src/block-lexer.ts", "../../@ts-stack/projects/markdown/ts-stack-markdown.ts"],
  "sourcesContent": ["/*\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nexport class ExtendRegexp {\n  private source: string;\n  private flags: string;\n\n  constructor(regex: RegExp, flags: string = '') {\n    this.source = regex.source;\n    this.flags = flags;\n  }\n\n  /**\n   * Extend regular expression.\n   *\n   * @param groupName Regular expression for search a group name.\n   * @param groupRegexp Regular expression of named group.\n   */\n  setGroup(groupName: RegExp | string, groupRegexp: RegExp | string): this {\n    let newRegexp: string = typeof groupRegexp == 'string' ? groupRegexp : groupRegexp.source;\n    newRegexp = newRegexp.replace(/(^|[^\\[])\\^/g, '$1');\n\n    // Extend regexp.\n    this.source = this.source.replace(groupName, newRegexp);\n    return this;\n  }\n\n  /**\n   * Returns a result of extending a regular expression.\n   */\n  getRegexp(): RegExp {\n    return new RegExp(this.source, this.flags);\n  }\n}\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { Replacements } from './interfaces';\n\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst replacements: Replacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  // tslint:disable-next-line:quotemark\n  \"'\": '&#39;',\n};\n\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, (ch: string) => replacements[ch]);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, (ch: string) => replacements[ch]);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // Explicitly match decimal, hex, and named HTML entities\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/gi, function (_, n) {\n    n = n.toLowerCase();\n\n    if (n === 'colon') {\n      return ':';\n    }\n\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n\n    return '';\n  });\n}\n", "/**\n * @license\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { escape, unescape } from './helpers';\nimport { Renderer } from './renderer';\n\nexport interface Obj {\n  [key: string]: any;\n}\n\nexport interface RulesBlockBase {\n  newline: RegExp;\n  code: RegExp;\n  hr: RegExp;\n  heading: RegExp;\n  lheading: RegExp;\n  blockquote: RegExp;\n  list: RegExp;\n  html: RegExp;\n  def: RegExp;\n  paragraph: RegExp;\n  text: RegExp;\n  bullet: RegExp;\n  /**\n   * List item (<li>).\n   */\n  item: RegExp;\n}\n\nexport interface RulesBlockGfm extends RulesBlockBase {\n  fences: RegExp;\n}\n\nexport interface RulesBlockTables extends RulesBlockGfm {\n  nptable: RegExp;\n  table: RegExp;\n}\n\nexport interface Link {\n  href: string;\n  title: string;\n}\n\nexport interface Links {\n  [key: string]: Link;\n}\n\nexport enum TokenType {\n  space = 1,\n  text,\n  paragraph,\n  heading,\n  listStart,\n  listEnd,\n  looseItemStart,\n  looseItemEnd,\n  listItemStart,\n  listItemEnd,\n  blockquoteStart,\n  blockquoteEnd,\n  code,\n  table,\n  html,\n  hr\n}\n\nexport type Align = 'center' | 'left' | 'right';\n\nexport interface Token {\n  type: number | string;\n  text?: string;\n  lang?: string;\n  /**\n   * Metadata of gfm code.\n   */\n  meta?: string;\n  depth?: number;\n  header?: string[];\n  align?: Align[];\n  cells?: string[][];\n  ordered?: boolean;\n  pre?: boolean;\n  escaped?: boolean;\n  execArr?: RegExpExecArray;\n  /**\n   * Used for debugging. Identifies the line number in the resulting HTML file.\n   */\n  line?: number;\n}\n\nexport interface RulesInlineBase {\n  escape: RegExp;\n  autolink: RegExp;\n  tag: RegExp;\n  link: RegExp;\n  reflink: RegExp;\n  nolink: RegExp;\n  strong: RegExp;\n  em: RegExp;\n  code: RegExp;\n  br: RegExp;\n  text: RegExp;\n  _inside: RegExp;\n  _href: RegExp;\n}\n\nexport interface RulesInlinePedantic extends RulesInlineBase {}\n\n/**\n * GFM Inline Grammar\n */\nexport interface RulesInlineGfm extends RulesInlineBase {\n  url: RegExp;\n  del: RegExp;\n}\n\nexport interface RulesInlineBreaks extends RulesInlineGfm {}\n\nexport class MarkedOptions {\n  gfm?: boolean = true;\n  tables?: boolean = true;\n  breaks?: boolean = false;\n  pedantic?: boolean = false;\n  sanitize?: boolean = false;\n  sanitizer?: (text: string) => string;\n  mangle?: boolean = true;\n  smartLists?: boolean = false;\n  silent?: boolean = false;\n  /**\n   * @param code The section of code to pass to the highlighter.\n   * @param lang The programming language specified in the code block.\n   */\n  highlight?: (code: string, lang?: string) => string;\n  langPrefix?: string = 'lang-';\n  smartypants?: boolean = false;\n  headerPrefix?: string = '';\n  /**\n   * An object containing functions to render tokens to HTML. Default: `new Renderer()`\n   */\n  renderer?: Renderer;\n  /**\n   * Self-close the tags for void elements (&lt;br/&gt;, &lt;img/&gt;, etc.)\n   * with a \"/\" as required by XHTML.\n   */\n  xhtml?: boolean = false;\n  /**\n   * The function that will be using to escape HTML entities.\n   * By default using inner helper.\n   */\n  escape?: (html: string, encode?: boolean) => string = escape;\n  /**\n   * The function that will be using to unescape HTML entities.\n   * By default using inner helper.\n   */\n  unescape?: (html: string) => string = unescape;\n  /**\n   * If set to `true`, an inline text will not be taken in paragraph.\n   *\n   * ```ts\n   * // isNoP == false\n   * Marked.parse('some text'); // returns '<p>some text</p>'\n   *\n   * Marked.setOptions({isNoP: true});\n   *\n   * Marked.parse('some text'); // returns 'some text'\n   * ```\n   */\n  isNoP?: boolean;\n}\n\nexport interface LexerReturns {\n  tokens: Token[];\n  links: Links;\n}\n\nexport interface DebugReturns extends LexerReturns {\n  result: string;\n}\n\nexport interface Replacements {\n  [key: string]: string;\n}\n\nexport interface RulesInlineCallback {\n  regexp?: RegExp;\n  condition(): RegExp;\n  tokenize(execArr: RegExpExecArray): void;\n}\n\nexport type SimpleRenderer = (execArr?: RegExpExecArray) => string;\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { Align, MarkedOptions } from './interfaces';\nimport { Marked } from './marked';\n\nexport class Renderer {\n  protected options: MarkedOptions;\n\n  constructor(options?: MarkedOptions) {\n    this.options = options || Marked.options;\n  }\n\n  code(code: string, lang?: string, escaped?: boolean, meta?: string): string {\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    const escapedCode = (escaped ? code : this.options.escape(code, true));\n\n    if (!lang) {\n      return `\\n<pre><code>${escapedCode}\\n</code></pre>\\n`;\n    }\n\n    const className = this.options.langPrefix + this.options.escape(lang, true);\n    return `\\n<pre><code class=\"${className}\">${escapedCode}\\n</code></pre>\\n`;\n  }\n\n  blockquote(quote: string): string {\n    return `<blockquote>\\n${quote}</blockquote>\\n`;\n  }\n\n  html(html: string): string {\n    return html;\n  }\n\n  heading(text: string, level: number, raw: string): string {\n    const id: string = this.options.headerPrefix + raw.toLowerCase().replace(/[^\\w]+/g, '-');\n\n    return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n  }\n\n  hr(): string {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body: string, ordered?: boolean): string {\n    const type = ordered ? 'ol' : 'ul';\n\n    return `\\n<${type}>\\n${body}</${type}>\\n`;\n  }\n\n  listitem(text: string): string {\n    return '<li>' + text + '</li>\\n';\n  }\n\n  paragraph(text: string): string {\n    return '<p>' + text + '</p>\\n';\n  }\n\n  table(header: string, body: string): string {\n    return `\n<table>\n<thead>\n${header}</thead>\n<tbody>\n${body}</tbody>\n</table>\n`;\n  }\n\n  tablerow(content: string): string {\n    return '<tr>\\n' + content + '</tr>\\n';\n  }\n\n  tablecell(content: string, flags: { header?: boolean; align?: Align }): string {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align ? '<' + type + ' style=\"text-align:' + flags.align + '\">' : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  }\n\n  // *** Inline level renderer methods. ***\n\n  strong(text: string): string {\n    return '<strong>' + text + '</strong>';\n  }\n\n  em(text: string): string {\n    return '<em>' + text + '</em>';\n  }\n\n  codespan(text: string): string {\n    return '<code>' + text + '</code>';\n  }\n\n  br(): string {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  del(text: string): string {\n    return '<del>' + text + '</del>';\n  }\n\n  link(href: string, title: string, text: string): string {\n    if (this.options.sanitize) {\n      let prot: string;\n\n      try {\n        prot = decodeURIComponent(this.options.unescape(href))\n          .replace(/[^\\w:]/g, '')\n          .toLowerCase();\n      } catch (e) {\n        return text;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return text;\n      }\n    }\n\n    let out = '<a href=\"' + href + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += '>' + text + '</a>';\n\n    return out;\n  }\n\n  image(href: string, title: string, text: string): string {\n    let out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += this.options.xhtml ? '/>' : '>';\n\n    return out;\n  }\n\n  text(text: string): string {\n    return text;\n  }\n}\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { ExtendRegexp } from './extend-regexp';\nimport {\n  Link,\n  Links,\n  MarkedOptions,\n  RulesInlineBase,\n  RulesInlineBreaks,\n  RulesInlineCallback,\n  RulesInlineGfm,\n  RulesInlinePedantic,\n} from './interfaces';\nimport { Marked } from './marked';\nimport { Renderer } from './renderer';\n\n/**\n * Inline Lexer & Compiler.\n */\nexport class InlineLexer {\n  protected static rulesBase: RulesInlineBase = null;\n  /**\n   * Pedantic Inline Grammar.\n   */\n  protected static rulesPedantic: RulesInlinePedantic = null;\n  /**\n   * GFM Inline Grammar\n   */\n  protected static rulesGfm: RulesInlineGfm = null;\n  /**\n   * GFM + Line Breaks Inline Grammar.\n   */\n  protected static rulesBreaks: RulesInlineBreaks = null;\n  protected rules: RulesInlineBase | RulesInlinePedantic | RulesInlineGfm | RulesInlineBreaks;\n  protected renderer: Renderer;\n  protected inLink: boolean;\n  protected hasRulesGfm: boolean;\n  protected ruleCallbacks: RulesInlineCallback[];\n\n  constructor(\n    protected staticThis: typeof InlineLexer,\n    protected links: Links,\n    protected options: MarkedOptions = Marked.options,\n    renderer?: Renderer\n  ) {\n    this.renderer = renderer || this.options.renderer || new Renderer(this.options);\n\n    if (!this.links) {\n      throw new Error(`InlineLexer requires 'links' parameter.`);\n    }\n\n    this.setRules();\n  }\n\n  /**\n   * Static Lexing/Compiling Method.\n   */\n  static output(src: string, links: Links, options: MarkedOptions): string {\n    const inlineLexer = new this(this, links, options);\n    return inlineLexer.output(src);\n  }\n\n  protected static getRulesBase(): RulesInlineBase {\n    if (this.rulesBase) {\n      return this.rulesBase;\n    }\n\n    /**\n     * Inline-Level Grammar.\n     */\n    const base: RulesInlineBase = {\n      escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n      autolink: /^<([^ <>]+(@|:\\/)[^ <>]+)>/,\n      tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^<'\">])*?>/,\n      link: /^!?\\[(inside)\\]\\(href\\)/,\n      reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n      nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n      strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n      em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n      code: /^(`+)([\\s\\S]*?[^`])\\1(?!`)/,\n      br: /^ {2,}\\n(?!\\s*$)/,\n      text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/,\n      _inside: /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/,\n      _href: /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/,\n    };\n\n    base.link = new ExtendRegexp(base.link).setGroup('inside', base._inside).setGroup('href', base._href).getRegexp();\n\n    base.reflink = new ExtendRegexp(base.reflink).setGroup('inside', base._inside).getRegexp();\n\n    return (this.rulesBase = base);\n  }\n\n  protected static getRulesPedantic(): RulesInlinePedantic {\n    if (this.rulesPedantic) {\n      return this.rulesPedantic;\n    }\n\n    return (this.rulesPedantic = {\n      ...this.getRulesBase(),\n      ...{\n        strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n      },\n    });\n  }\n\n  protected static getRulesGfm(): RulesInlineGfm {\n    if (this.rulesGfm) {\n      return this.rulesGfm;\n    }\n\n    const base = this.getRulesBase();\n\n    const escape = new ExtendRegexp(base.escape).setGroup('])', '~|])').getRegexp();\n\n    const text = new ExtendRegexp(base.text).setGroup(']|', '~]|').setGroup('|', '|https?://|').getRegexp();\n\n    return (this.rulesGfm = {\n      ...base,\n      ...{\n        escape,\n        url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n        del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n        text,\n      },\n    });\n  }\n\n  protected static getRulesBreaks(): RulesInlineBreaks {\n    if (this.rulesBreaks) {\n      return this.rulesBreaks;\n    }\n\n    const inline = this.getRulesGfm();\n    const gfm = this.getRulesGfm();\n\n    return (this.rulesBreaks = {\n      ...gfm,\n      ...{\n        br: new ExtendRegexp(inline.br).setGroup('{2,}', '*').getRegexp(),\n        text: new ExtendRegexp(gfm.text).setGroup('{2,}', '*').getRegexp(),\n      },\n    });\n  }\n\n  protected setRules() {\n    if (this.options.gfm) {\n      if (this.options.breaks) {\n        this.rules = this.staticThis.getRulesBreaks();\n      } else {\n        this.rules = this.staticThis.getRulesGfm();\n      }\n    } else if (this.options.pedantic) {\n      this.rules = this.staticThis.getRulesPedantic();\n    } else {\n      this.rules = this.staticThis.getRulesBase();\n    }\n\n    this.hasRulesGfm = (this.rules as RulesInlineGfm).url !== undefined;\n  }\n\n  /**\n   * Lexing/Compiling.\n   */\n  output(nextPart: string): string {\n    nextPart = nextPart;\n    let execArr: RegExpExecArray;\n    let out = '';\n\n    while (nextPart) {\n      // escape\n      if ((execArr = this.rules.escape.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += execArr[1];\n        continue;\n      }\n\n      // autolink\n      if ((execArr = this.rules.autolink.exec(nextPart))) {\n        let text: string;\n        let href: string;\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[2] === '@') {\n          text = this.options.escape(\n            execArr[1].charAt(6) === ':' ? this.mangle(execArr[1].substring(7)) : this.mangle(execArr[1])\n          );\n          href = this.mangle('mailto:') + text;\n        } else {\n          text = this.options.escape(execArr[1]);\n          href = text;\n        }\n\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.inLink && this.hasRulesGfm && (execArr = (this.rules as RulesInlineGfm).url.exec(nextPart))) {\n        let text: string;\n        let href: string;\n        nextPart = nextPart.substring(execArr[0].length);\n        text = this.options.escape(execArr[1]);\n        href = text;\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // tag\n      if ((execArr = this.rules.tag.exec(nextPart))) {\n        if (!this.inLink && /^<a /i.test(execArr[0])) {\n          this.inLink = true;\n        } else if (this.inLink && /^<\\/a>/i.test(execArr[0])) {\n          this.inLink = false;\n        }\n\n        nextPart = nextPart.substring(execArr[0].length);\n\n        out += this.options.sanitize\n          ? this.options.sanitizer\n            ? this.options.sanitizer(execArr[0])\n            : this.options.escape(execArr[0])\n          : execArr[0];\n        continue;\n      }\n\n      // link\n      if ((execArr = this.rules.link.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.inLink = true;\n\n        out += this.outputLink(execArr, {\n          href: execArr[2],\n          title: execArr[3],\n        });\n\n        this.inLink = false;\n        continue;\n      }\n\n      // reflink, nolink\n      if ((execArr = this.rules.reflink.exec(nextPart)) || (execArr = this.rules.nolink.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const keyLink = (execArr[2] || execArr[1]).replace(/\\s+/g, ' ');\n        const link = this.links[keyLink.toLowerCase()];\n\n        if (!link || !link.href) {\n          out += execArr[0].charAt(0);\n          nextPart = execArr[0].substring(1) + nextPart;\n          continue;\n        }\n\n        this.inLink = true;\n        out += this.outputLink(execArr, link);\n        this.inLink = false;\n        continue;\n      }\n\n      // strong\n      if ((execArr = this.rules.strong.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.strong(this.output(execArr[2] || execArr[1]));\n        continue;\n      }\n\n      // em\n      if ((execArr = this.rules.em.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.em(this.output(execArr[2] || execArr[1]));\n        continue;\n      }\n\n      // code\n      if ((execArr = this.rules.code.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.codespan(this.options.escape(execArr[2].trim(), true));\n        continue;\n      }\n\n      // br\n      if ((execArr = this.rules.br.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.br();\n        continue;\n      }\n\n      // del (gfm)\n      if (this.hasRulesGfm && (execArr = (this.rules as RulesInlineGfm).del.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.del(this.output(execArr[1]));\n        continue;\n      }\n\n      // text\n      if ((execArr = this.rules.text.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        out += this.renderer.text(this.options.escape(this.smartypants(execArr[0])));\n        continue;\n      }\n\n      if (nextPart) {\n        throw new Error('Infinite loop on byte: ' + nextPart.charCodeAt(0));\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Compile Link.\n   */\n  protected outputLink(execArr: RegExpExecArray, link: Link) {\n    const href = this.options.escape(link.href);\n    const title = link.title ? this.options.escape(link.title) : null;\n\n    return execArr[0].charAt(0) !== '!'\n      ? this.renderer.link(href, title, this.output(execArr[1]))\n      : this.renderer.image(href, title, this.options.escape(execArr[1]));\n  }\n\n  /**\n   * Smartypants Transformations.\n   */\n  protected smartypants(text: string) {\n    if (!this.options.smartypants) {\n      return text;\n    }\n\n    return (\n      text\n        // em-dashes\n        .replace(/---/g, '\\u2014')\n        // en-dashes\n        .replace(/--/g, '\\u2013')\n        // opening singles\n        .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n        // closing singles & apostrophes\n        .replace(/'/g, '\\u2019')\n        // opening doubles\n        .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n        // closing doubles\n        .replace(/\"/g, '\\u201d')\n        // ellipses\n        .replace(/\\.{3}/g, '\\u2026')\n    );\n  }\n\n  /**\n   * Mangle Links.\n   */\n  protected mangle(text: string) {\n    if (!this.options.mangle) {\n      return text;\n    }\n\n    let out = '';\n    const length = text.length;\n\n    for (let i = 0; i < length; i++) {\n      let str: string;\n\n      if (Math.random() > 0.5) {\n        str = 'x' + text.charCodeAt(i).toString(16);\n      }\n\n      out += '&#' + str + ';';\n    }\n\n    return out;\n  }\n}\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { InlineLexer } from './inline-lexer';\nimport { Links, MarkedOptions, SimpleRenderer, Token, TokenType } from './interfaces';\nimport { Marked } from './marked';\nimport { Renderer } from './renderer';\n\n/**\n * Parsing & Compiling.\n */\nexport class Parser {\n  simpleRenderers: SimpleRenderer[] = [];\n  protected tokens: Token[];\n  protected token: Token;\n  protected inlineLexer: InlineLexer;\n  protected options: MarkedOptions;\n  protected renderer: Renderer;\n  protected line: number = 0;\n\n  constructor(options?: MarkedOptions) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || Marked.options;\n    this.renderer = this.options.renderer || new Renderer(this.options);\n  }\n\n  static parse(tokens: Token[], links: Links, options?: MarkedOptions): string {\n    const parser = new this(options);\n    return parser.parse(links, tokens);\n  }\n\n  parse(links: Links, tokens: Token[]) {\n    this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);\n    this.tokens = tokens.reverse();\n\n    let out = '';\n\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  }\n\n  debug(links: Links, tokens: Token[]) {\n    this.inlineLexer = new InlineLexer(InlineLexer, links, this.options, this.renderer);\n    this.tokens = tokens.reverse();\n\n    let out = '';\n\n    while (this.next()) {\n      const outToken: string = this.tok();\n      this.token.line = this.line += outToken.split('\\n').length - 1;\n      out += outToken;\n    }\n\n    return out;\n  }\n\n  protected next() {\n    return (this.token = this.tokens.pop());\n  }\n\n  protected getNextElement() {\n    return this.tokens[this.tokens.length - 1];\n  }\n\n  protected parseText() {\n    let body = this.token.text;\n    let nextElement: Token;\n\n    while ((nextElement = this.getNextElement()) && nextElement.type == TokenType.text) {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inlineLexer.output(body);\n  }\n\n  protected tok() {\n    switch (this.token.type) {\n      case TokenType.space: {\n        return '';\n      }\n      case TokenType.paragraph: {\n        return this.renderer.paragraph(this.inlineLexer.output(this.token.text));\n      }\n      case TokenType.text: {\n        if (this.options.isNoP) {\n          return this.parseText();\n        } else {\n          return this.renderer.paragraph(this.parseText());\n        }\n      }\n      case TokenType.heading: {\n        return this.renderer.heading(this.inlineLexer.output(this.token.text), this.token.depth, this.token.text);\n      }\n      case TokenType.listStart: {\n        let body = '';\n        const ordered = this.token.ordered;\n\n        while (this.next().type != TokenType.listEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.list(body, ordered);\n      }\n      case TokenType.listItemStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.listItemEnd) {\n          body += this.token.type == (TokenType.text as any) ? this.parseText() : this.tok();\n        }\n\n        return this.renderer.listitem(body);\n      }\n      case TokenType.looseItemStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.listItemEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.listitem(body);\n      }\n      case TokenType.code: {\n        return this.renderer.code(this.token.text, this.token.lang, this.token.escaped, this.token.meta);\n      }\n      case TokenType.table: {\n        let header = '';\n        let body = '';\n        let cell;\n\n        // header\n        cell = '';\n        for (let i = 0; i < this.token.header.length; i++) {\n          const flags = { header: true, align: this.token.align[i] };\n          const out = this.inlineLexer.output(this.token.header[i]);\n\n          cell += this.renderer.tablecell(out, flags);\n        }\n\n        header += this.renderer.tablerow(cell);\n\n        for (const row of this.token.cells) {\n          cell = '';\n\n          for (let j = 0; j < row.length; j++) {\n            cell += this.renderer.tablecell(this.inlineLexer.output(row[j]), {\n              header: false,\n              align: this.token.align[j]\n            });\n          }\n\n          body += this.renderer.tablerow(cell);\n        }\n\n        return this.renderer.table(header, body);\n      }\n      case TokenType.blockquoteStart: {\n        let body = '';\n\n        while (this.next().type != TokenType.blockquoteEnd) {\n          body += this.tok();\n        }\n\n        return this.renderer.blockquote(body);\n      }\n      case TokenType.hr: {\n        return this.renderer.hr();\n      }\n      case TokenType.html: {\n        const html =\n          !this.token.pre && !this.options.pedantic ? this.inlineLexer.output(this.token.text) : this.token.text;\n        return this.renderer.html(html);\n      }\n      default: {\n        if (this.simpleRenderers.length) {\n          for (let i = 0; i < this.simpleRenderers.length; i++) {\n            if (this.token.type == 'simpleRule' + (i + 1)) {\n              return this.simpleRenderers[i].call(this.renderer, this.token.execArr);\n            }\n          }\n        }\n\n        const errMsg = `Token with \"${this.token.type}\" type was not found.`;\n\n        if (this.options.silent) {\n          console.log(errMsg);\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n  }\n}\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { BlockLexer } from './block-lexer';\nimport { DebugReturns, LexerReturns, Links, MarkedOptions, SimpleRenderer, Token, TokenType } from './interfaces';\nimport { Parser } from './parser';\n\nexport class Marked {\n  static options = new MarkedOptions();\n  protected static simpleRenderers: SimpleRenderer[] = [];\n\n  /**\n   * Merges the default options with options that will be set.\n   *\n   * @param options Hash of options.\n   */\n  static setOptions(options: MarkedOptions) {\n    Object.assign(this.options, options);\n    return this;\n  }\n\n  /**\n   * Setting simple block rule.\n   */\n  static setBlockRule(regexp: RegExp, renderer: SimpleRenderer = () => '') {\n    BlockLexer.simpleRules.push(regexp);\n    this.simpleRenderers.push(renderer);\n\n    return this;\n  }\n\n  /**\n   * Accepts Markdown text and returns text in HTML format.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options. They replace, but do not merge with the default options.\n   * If you want the merging, you can to do this via `Marked.setOptions()`.\n   */\n  static parse(src: string, options: MarkedOptions = this.options): string {\n    try {\n      const { tokens, links } = this.callBlockLexer(src, options);\n      return this.callParser(tokens, links, options);\n    } catch (e) {\n      return this.callMe(e);\n    }\n  }\n\n  /**\n   * Accepts Markdown text and returns object with text in HTML format,\n   * tokens and links from `BlockLexer.parser()`.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options. They replace, but do not merge with the default options.\n   * If you want the merging, you can to do this via `Marked.setOptions()`.\n   */\n  static debug(src: string, options: MarkedOptions = this.options): DebugReturns {\n    const { tokens, links } = this.callBlockLexer(src, options);\n    let origin = tokens.slice();\n    const parser = new Parser(options);\n    parser.simpleRenderers = this.simpleRenderers;\n    const result = parser.debug(links, tokens);\n\n    /**\n     * Translates a token type into a readable form,\n     * and moves `line` field to a first place in a token object.\n     */\n    origin = origin.map(token => {\n      token.type = (TokenType as any)[token.type] || token.type;\n\n      const line = token.line;\n      delete token.line;\n      if (line) {\n        return { ...{ line }, ...token };\n      } else {\n        return token;\n      }\n    });\n\n    return { tokens: origin, links, result };\n  }\n\n  protected static callBlockLexer(src: string = '', options?: MarkedOptions): LexerReturns {\n    if (typeof src != 'string') {\n      throw new Error(`Expected that the 'src' parameter would have a 'string' type, got '${typeof src}'`);\n    }\n\n    // Preprocessing.\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ')\n      .replace(/\\u00a0/g, ' ')\n      .replace(/\\u2424/g, '\\n')\n      .replace(/^ +$/gm, '');\n\n    return BlockLexer.lex(src, options, true);\n  }\n\n  protected static callParser(tokens: Token[], links: Links, options?: MarkedOptions): string {\n    if (this.simpleRenderers.length) {\n      const parser = new Parser(options);\n      parser.simpleRenderers = this.simpleRenderers;\n      return parser.parse(links, tokens);\n    } else {\n      return Parser.parse(tokens, links, options);\n    }\n  }\n\n  protected static callMe(err: Error) {\n    err.message += '\\nPlease report this to https://github.com/ts-stack/markdown';\n\n    if (this.options.silent) {\n      return '<p>An error occured:</p><pre>' + this.options.escape(err.message + '', true) + '</pre>';\n    }\n\n    throw err;\n  }\n}\n", "/**\n * @license\n *\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n *\n * Copyright (c) 2018-2021, \u041A\u043E\u0441\u0442\u044F \u0422\u0440\u0435\u0442\u044F\u043A. (MIT Licensed)\n * https://github.com/ts-stack/markdown\n */\n\nimport { ExtendRegexp } from './extend-regexp';\nimport {\n  Align,\n  LexerReturns,\n  Links,\n  MarkedOptions,\n  RulesBlockBase,\n  RulesBlockGfm,\n  RulesBlockTables,\n  Token,\n  TokenType,\n} from './interfaces';\nimport { Marked } from './marked';\n\nexport class BlockLexer<T extends typeof BlockLexer> {\n  static simpleRules: RegExp[] = [];\n  protected static rulesBase: RulesBlockBase = null;\n  /**\n   * GFM Block Grammar.\n   */\n  protected static rulesGfm: RulesBlockGfm = null;\n  /**\n   * GFM + Tables Block Grammar.\n   */\n  protected static rulesTables: RulesBlockTables = null;\n  protected rules: RulesBlockBase | RulesBlockGfm | RulesBlockTables;\n  protected options: MarkedOptions;\n  protected links: Links = {};\n  protected tokens: Token[] = [];\n  protected hasRulesGfm: boolean;\n  protected hasRulesTables: boolean;\n\n  constructor(protected staticThis: T, options?: object) {\n    this.options = options || Marked.options;\n    this.setRules();\n  }\n\n  /**\n   * Accepts Markdown text and returns object with tokens and links.\n   *\n   * @param src String of markdown source to be compiled.\n   * @param options Hash of options.\n   */\n  static lex(src: string, options?: MarkedOptions, top?: boolean, isBlockQuote?: boolean): LexerReturns {\n    const lexer = new this(this, options);\n    return lexer.getTokens(src, top, isBlockQuote);\n  }\n\n  protected static getRulesBase(): RulesBlockBase {\n    if (this.rulesBase) {\n      return this.rulesBase;\n    }\n\n    const base: RulesBlockBase = {\n      newline: /^\\n+/,\n      code: /^( {4}[^\\n]+\\n*)+/,\n      hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n      heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n      lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n      blockquote: /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+/,\n      list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n      html: /^ *(?:comment *(?:\\n|\\s*$)|closed *(?:\\n{2,}|\\s*$)|closing *(?:\\n{2,}|\\s*$))/,\n      def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n      paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n      text: /^[^\\n]+/,\n      bullet: /(?:[*+-]|\\d+\\.)/,\n      item: /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/,\n    };\n\n    base.item = new ExtendRegexp(base.item, 'gm').setGroup(/bull/g, base.bullet).getRegexp();\n\n    base.list = new ExtendRegexp(base.list)\n      .setGroup(/bull/g, base.bullet)\n      .setGroup('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n      .setGroup('def', '\\\\n+(?=' + base.def.source + ')')\n      .getRegexp();\n\n    const tag =\n      '(?!(?:' +\n      'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' +\n      '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' +\n      '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\n    base.html = new ExtendRegexp(base.html)\n      .setGroup('comment', /<!--[\\s\\S]*?-->/)\n      .setGroup('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n      .setGroup('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n      .setGroup(/tag/g, tag)\n      .getRegexp();\n\n    base.paragraph = new ExtendRegexp(base.paragraph)\n      .setGroup('hr', base.hr)\n      .setGroup('heading', base.heading)\n      .setGroup('lheading', base.lheading)\n      .setGroup('blockquote', base.blockquote)\n      .setGroup('tag', '<' + tag)\n      .setGroup('def', base.def)\n      .getRegexp();\n\n    return (this.rulesBase = base);\n  }\n\n  protected static getRulesGfm(): RulesBlockGfm {\n    if (this.rulesGfm) {\n      return this.rulesGfm;\n    }\n\n    const base = this.getRulesBase();\n\n    const gfm: RulesBlockGfm = {\n      ...base,\n      ...{\n        fences: /^ *(`{3,}|~{3,})[ \\.]*((\\S+)? *[^\\n]*)\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/,\n        paragraph: /^/,\n        heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/,\n      },\n    };\n\n    const group1 = gfm.fences.source.replace('\\\\1', '\\\\2');\n    const group2 = base.list.source.replace('\\\\1', '\\\\3');\n\n    gfm.paragraph = new ExtendRegexp(base.paragraph).setGroup('(?!', `(?!${group1}|${group2}|`).getRegexp();\n\n    return (this.rulesGfm = gfm);\n  }\n\n  protected static getRulesTable(): RulesBlockTables {\n    if (this.rulesTables) {\n      return this.rulesTables;\n    }\n\n    return (this.rulesTables = {\n      ...this.getRulesGfm(),\n      ...{\n        nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n        table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n      },\n    });\n  }\n\n  protected setRules() {\n    if (this.options.gfm) {\n      if (this.options.tables) {\n        this.rules = this.staticThis.getRulesTable();\n      } else {\n        this.rules = this.staticThis.getRulesGfm();\n      }\n    } else {\n      this.rules = this.staticThis.getRulesBase();\n    }\n\n    this.hasRulesGfm = (this.rules as RulesBlockGfm).fences !== undefined;\n    this.hasRulesTables = (this.rules as RulesBlockTables).table !== undefined;\n  }\n\n  /**\n   * Lexing.\n   */\n  protected getTokens(src: string, top?: boolean, isBlockQuote?: boolean): LexerReturns {\n    let nextPart = src;\n    let execArr: RegExpExecArray;\n\n    mainLoop: while (nextPart) {\n      // newline\n      if ((execArr = this.rules.newline.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[0].length > 1) {\n          this.tokens.push({ type: TokenType.space });\n        }\n      }\n\n      // code\n      if ((execArr = this.rules.code.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const code = execArr[0].replace(/^ {4}/gm, '');\n\n        this.tokens.push({\n          type: TokenType.code,\n          text: !this.options.pedantic ? code.replace(/\\n+$/, '') : code,\n        });\n        continue;\n      }\n\n      // fences code (gfm)\n      if (this.hasRulesGfm && (execArr = (this.rules as RulesBlockGfm).fences.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.tokens.push({\n          type: TokenType.code,\n          meta: execArr[2],\n          lang: execArr[3],\n          text: execArr[4] || '',\n        });\n        continue;\n      }\n\n      // heading\n      if ((execArr = this.rules.heading.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({\n          type: TokenType.heading,\n          depth: execArr[1].length,\n          text: execArr[2],\n        });\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (top && this.hasRulesTables && (execArr = (this.rules as RulesBlockTables).nptable.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        const item: Token = {\n          type: TokenType.table,\n          header: execArr[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n          align: execArr[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */) as Align[],\n          cells: [],\n        };\n\n        for (let i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        const td: string[] = execArr[3].replace(/\\n$/, '').split('\\n');\n\n        for (let i = 0; i < td.length; i++) {\n          item.cells[i] = td[i].split(/ *\\| */);\n        }\n\n        this.tokens.push(item);\n        continue;\n      }\n\n      // lheading\n      if ((execArr = this.rules.lheading.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.tokens.push({\n          type: TokenType.heading,\n          depth: execArr[2] === '=' ? 1 : 2,\n          text: execArr[1],\n        });\n        continue;\n      }\n\n      // hr\n      if ((execArr = this.rules.hr.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.hr });\n        continue;\n      }\n\n      // blockquote\n      if ((execArr = this.rules.blockquote.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.blockquoteStart });\n        const str = execArr[0].replace(/^ *> ?/gm, '');\n\n        // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        this.getTokens(str);\n        this.tokens.push({ type: TokenType.blockquoteEnd });\n        continue;\n      }\n\n      // list\n      if ((execArr = this.rules.list.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const bull: string = execArr[2];\n\n        this.tokens.push({ type: TokenType.listStart, ordered: bull.length > 1 });\n\n        // Get each top-level item.\n        const str = execArr[0].match(this.rules.item);\n        const length = str.length;\n\n        let next = false;\n        let space: number;\n        let blockBullet: string;\n        let loose: boolean;\n\n        for (let i = 0; i < length; i++) {\n          let item = str[i];\n\n          // Remove the list item's bullet so it is seen as the next token.\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n          // Outdent whatever the list item contains. Hacky.\n          if (item.indexOf('\\n ') !== -1) {\n            space -= item.length;\n            item = !this.options.pedantic\n              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n              : item.replace(/^ {1,4}/gm, '');\n          }\n\n          // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n          if (this.options.smartLists && i !== length - 1) {\n            blockBullet = this.staticThis.getRulesBase().bullet.exec(str[i + 1])[0];\n\n            if (bull !== blockBullet && !(bull.length > 1 && blockBullet.length > 1)) {\n              nextPart = str.slice(i + 1).join('\\n') + nextPart;\n              i = length - 1;\n            }\n          }\n\n          // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== length - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n\n            if (!loose) {\n              loose = next;\n            }\n          }\n\n          this.tokens.push({ type: loose ? TokenType.looseItemStart : TokenType.listItemStart });\n\n          // Recurse.\n          this.getTokens(item, false, isBlockQuote);\n          this.tokens.push({ type: TokenType.listItemEnd });\n        }\n\n        this.tokens.push({ type: TokenType.listEnd });\n        continue;\n      }\n\n      // html\n      if ((execArr = this.rules.html.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        const attr = execArr[1];\n        const isPre = attr === 'pre' || attr === 'script' || attr === 'style';\n\n        this.tokens.push({\n          type: this.options.sanitize ? TokenType.paragraph : TokenType.html,\n          pre: !this.options.sanitizer && isPre,\n          text: execArr[0],\n        });\n        continue;\n      }\n\n      // def\n      if (top && (execArr = this.rules.def.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        this.links[execArr[1].toLowerCase()] = {\n          href: execArr[2],\n          title: execArr[3],\n        };\n        continue;\n      }\n\n      // table (gfm)\n      if (top && this.hasRulesTables && (execArr = (this.rules as RulesBlockTables).table.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        const item: Token = {\n          type: TokenType.table,\n          header: execArr[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n          align: execArr[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */) as Align[],\n          cells: [],\n        };\n\n        for (let i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        const td = execArr[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n');\n\n        for (let i = 0; i < td.length; i++) {\n          item.cells[i] = td[i].replace(/^ *\\| *| *\\| *$/g, '').split(/ *\\| */);\n        }\n\n        this.tokens.push(item);\n        continue;\n      }\n\n      // simple rules\n      if (this.staticThis.simpleRules.length) {\n        const simpleRules = this.staticThis.simpleRules;\n        for (let i = 0; i < simpleRules.length; i++) {\n          if ((execArr = simpleRules[i].exec(nextPart))) {\n            nextPart = nextPart.substring(execArr[0].length);\n            const type = 'simpleRule' + (i + 1);\n            this.tokens.push({ type, execArr });\n            continue mainLoop;\n          }\n        }\n      }\n\n      // top-level paragraph\n      if (top && (execArr = this.rules.paragraph.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n\n        if (execArr[1].slice(-1) === '\\n') {\n          this.tokens.push({\n            type: TokenType.paragraph,\n            text: execArr[1].slice(0, -1),\n          });\n        } else {\n          this.tokens.push({\n            type: this.tokens.length > 0 ? TokenType.paragraph : TokenType.text,\n            text: execArr[1],\n          });\n        }\n        continue;\n      }\n\n      // text\n      // Top-level should never reach here.\n      if ((execArr = this.rules.text.exec(nextPart))) {\n        nextPart = nextPart.substring(execArr[0].length);\n        this.tokens.push({ type: TokenType.text, text: execArr[0] });\n        continue;\n      }\n\n      if (nextPart) {\n        throw new Error(\n          'Infinite loop on byte: ' + nextPart.charCodeAt(0) + `, near text '${nextPart.slice(0, 30)}...'`\n        );\n      }\n    }\n\n    return { tokens: this.tokens, links: this.links };\n  }\n}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["TokenType", "escape"]
}
