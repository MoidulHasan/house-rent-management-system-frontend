/**
 * Null or whatever
 *
 * @category Type Alias
 *
 * @typeParam D - Type of data which is nullable
 */
declare type Nullable<T> = T | null | undefined;
/**
 * Array, or not yet
 *
 * @category Type Alias
 *
 * @typeParam D - Type of data which can be arrayed
 */
declare type Arrayable<T> = T | Array<T>;
/**
 * Function
 *
 * @category Type Alias
 *
 * @typeParam D - Type of data the Function return
 */
declare type Func<T = void> = () => T;
/**
 * Merging
 *
 * @category Type Alias
 */
declare type MergeInsertions<T> = T extends object ? {
    [K in keyof T]: MergeInsertions<T[K]>;
} : T;
/**
 * Very Deep Merging
 *
 * @category Type Alias
 */
declare type DeepMerge<F, S> = MergeInsertions<{
    [K in keyof F | keyof S]: K extends keyof S & keyof F ? DeepMerge<F[K], S[K]> : K extends keyof S ? S[K] : K extends keyof F ? F[K] : never;
}>;

/**
 * Convert `Arrayable<T>` to `Array<T>`
 *
 * @category Array
 */
declare function toArray<T>(array?: Nullable<Arrayable<T>>): Array<T>;
/**
 * Convert `Arrayable<T>` to `Array<T>` and flatten it
 *
 * @category Array
 */
declare function flattenArrayable<T>(array?: Nullable<Arrayable<T | Array<T>>>): Array<T>;
/**
 * Use rest arguments to merge arrays
 *
 * @category Array
 */
declare function mergeArrayable<T>(...args: Nullable<Arrayable<T>>[]): Array<T>;
declare type PartitionFilter<T> = (i: T, idx: number, arr: readonly T[]) => any;
/**
 * Divide an array into two parts by a filter function
 *
 * @category Array
 * @example const [odd, even] = partition([1, 2, 3, 4], i => i % 2 != 0)
 */
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>): [T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>): [T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>): [T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>): [T[], T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>, f5: PartitionFilter<T>): [T[], T[], T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>, f5: PartitionFilter<T>, f6: PartitionFilter<T>): [T[], T[], T[], T[], T[], T[], T[]];
/**
 * Unique an Array
 *
 * @category Array
 */
declare function uniq<T>(array: readonly T[]): T[];
/**
 * Get last item
 *
 * @category Array
 */
declare function last(array: readonly []): undefined;
declare function last<T>(array: readonly T[]): T;
/**
 * Remove an item from Array
 *
 * @category Array
 */
declare function remove<T>(array: T[], value: T): boolean;
/**
 * Get nth item of Array. Negative for backward
 *
 * @category Array
 */
declare function at(array: readonly [], index: number): undefined;
declare function at<T>(array: readonly T[], index: number): T;
/**
 * Generate a range array of numbers. The `stop` is exclusive.
 *
 * @category Array
 */
declare function range(stop: number): number[];
declare function range(start: number, stop: number, step?: number): number[];
/**
 * Move element in an Array
 *
 * @category Array
 * @param arr
 * @param from
 * @param to
 */
declare function move<T>(arr: T[], from: number, to: number): T[];
/**
 * Clamp a number to the index ranage of an array
 *
 * @category Array
 */
declare function clampArrayRange(n: number, arr: readonly unknown[]): number;
/**
 * Get random items from an array
 *
 * @category Array
 */
declare function sample<T>(arr: T[], count: number): T[];
/**
 * Shuffle an array. This function mutates the array.
 *
 * @category Array
 */
declare function shuffle<T>(array: T[]): T[];

/**
 * Assert
 *
 * @param condition -
 * @param message -
 *
 */
declare const assert: (condition: boolean, message: string) => asserts condition;
/**
 * Convert to String
 *
 * @param val -
 *
 * @returns - Converted String
 *
 */
declare const toString: (val: any) => string;
/**
 * Noop
 */
declare const noop: () => void;

declare type EventType = string | symbol;
declare type Handler<T = unknown> = (event: T) => void;
declare class Emitter<Events extends Record<EventType, unknown>> {
    private readonly _t;
    constructor();
    on<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>, ctx?: {}): void;
    off<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>): void;
    emit<Key extends keyof Events>(event: Key, args: Events[keyof Events]): boolean;
    once<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>, ctx?: {}): void;
}

/**
 * Call every function in an array
 *
 * @category Function
 *
 * @param functions
 */
declare function batchInvoke(functions: Nullable<Func>[]): void;
/**
 * Call the function
 *
 * @category Function
 *
 * @param fn
 */
declare function invoke(fn: Func): void;
/**
 * Pass the value through the callback, and return the value
 *
 * @category Function
 *
 * @param val
 * @param callback
 *
 * @typeParam T
 * @typeParam D
 *
 * @example
 * ```
 * function createUser(name: string): User {
 *   return tap(new User, user => {
 *     user.name = name
 *   })
 * }
 * ```
 */
declare function tap<T, D = T>(val: T, callback: (val: T) => void | D): void | D;

/**
 * Type guard to filter out null-ish values
 *
 * @category Guards
 * @example array.filter(notNullish)
 */
declare function notNullish<T>(v: T | null | undefined): v is NonNullable<T>;
/**
 * Type guard to filter out null values
 *
 * @category Guards
 * @example array.filter(noNull)
 */
declare function noNull<T>(v: T | null): v is Exclude<T, null>;
/**
 * Type guard to filter out null-ish values
 *
 * @category Guards
 * @example array.filter(notUndefined)
 */
declare function notUndefined<T>(v: T): v is Exclude<T, undefined>;
/**
 * Type guard to filter out falsy values
 *
 * @category Guards
 * @example array.filter(isTruthy)
 */
declare function isTruthy<T>(v: T): v is NonNullable<T>;

/**
 * @category Is Type
 *
 * @param val
 * @typeParam T
 *
 * @returns - Boolean
 *
 */
declare const isDef: <T = any>(val?: T | undefined) => val is T;
/**
 * Check if value is boolean
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isBoolean: (val: any) => val is boolean;
/**
 * Check if value is Function
 * @category Is Type
 *
 * @param val
 * @typeParam T
 * @returns - Boolean
 *
 */
declare const isFunction: <T extends Function>(val: any) => val is T;
/**
 * Check if value is Number
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isNumber: (val: any) => val is number;
/**
 * Check if value is Numberish
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isNumberish: (val: any) => val is number;
/**
 * Check if value is String
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isString: (val: unknown) => val is string;
/**
 * Check if value is Object
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isObject: <T extends object>(val: any) => val is T;
/**
 * Check if is Array
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isArray: <T = any>(val: any) => val is T[];
/**
 * Check if window defined
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isWindow: (val: any) => boolean;
/**
 * Check if in Browser
 * @category Is Type
 *
 * @returns - Boolean
 *
 */
declare const isBrowser: boolean;
/**
 * Check if it has console
 * @category Is Type
 *
 * @returns - Boolean
 *
 */
declare const hasConsole: boolean;

/**
 * Clamp any number
 *
 * @param n - Number for clamp
 * @param min - Starting Number for clamp range
 * @param max - Ending Number for clamp range
 *
 * @returns The clamped value of given `n`
 */
declare function clamp(n: number, min: number, max: number): number;
/**
 * Sum any amount of number
 *
 * @param args - Numbers you need to sum
 *
 * @returns The summation of given `args`
 */
declare function sum(...args: number[] | number[][]): number;

/**
 * Map key/value pairs for an object, and construct a new one
 *
 *
 * @category Object
 *
 * Transform:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])
 * // { A: '1', B: '2' }
 * ```
 *
 * Swap key/value:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [v, k])
 * // { 1: 'a', 2: 'b' }
 * ```
 *
 * Filter keys:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])
 * // { b: 2 }
 * ```
 */
declare function objectMap<K extends string, V, NK = K, NV = V>(obj: Record<K, V>, fn: (key: K, value: V) => [NK, NV] | undefined): Record<K, V>;
/**
 * Type guard for any key, `k`.
 * Marks `k` as a key of `T` if `k` is in `obj`.
 *
 * @category Object
 *
 * @param obj object to query for key `k`
 * @param k key to check existence in `obj`
 *
 * @typeParam T
 */
declare function isKeyOf<T extends object>(obj: T, k: keyof any): k is keyof T;
/**
 * Strict typed `Object.keys`
 *
 * @category Object
 *
 * @param obj
 *
 * @typeParam T
 */
declare function objectKeys<T extends object>(obj: T): (keyof T)[];
/**
 * Strict typed `Object.entries`
 *
 * @category Object
 *
 * @param obj
 *
 * @typeParam T
 */
declare function objectEntries<T extends object>(obj: T): [keyof T, T[keyof T]][];
/**
 * Deep merge :P
 *
 * @category Object
 *
 * @param target
 * @param sources
 *
 * @typeParam T
 * @typeParam S
 */
declare function deepMerge<T extends object = object, S extends object = T>(target: T, ...sources: S[]): DeepMerge<T, S>;
/**
 * Create a new subset object by giving keys
 *
 * @category Object
 *
 * @param obj
 * @param keys
 * @param omitUndefined
 *
 * @typeParam O
 * @typeParam T
 */
declare function objectPick<O, T extends keyof O>(obj: O, keys: T[], omitUndefined?: boolean): Pick<O, T>;
/**
 * Clear undefined fields from an object. It mutates the object
 *
 * @category Object
 *
 * @param obj
 * @typeParam T
 */
declare function clearUndefined<T extends object>(obj: T): T;
/**
 * Determines whether an object has a property with the specified name
 *
 * @category Object
 *
 * @param obj
 * @param key
 * @typeParam T
 */
declare function hasOwnProperty<T>(obj: T, key: PropertyKey): boolean;

/**
 * @category Interface
 */
interface SingletonPromiseReturn<T> {
    (): Promise<T>;
    /**
     * Reset current staled promise.
     * Await it to have proper shutdown.
     */
    reset: () => Promise<void>;
}
/**
 * Create singleton promise function
 *
 * @category Promise
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): SingletonPromiseReturn<T>;
/**
 * Promised `setTimeout`
 *
 * @category Promise
 */
declare function sleep(ms: number, callback?: Func<any>): Promise<void>;
/**
 * Create a promise lock
 *
 * @category Promise
 * @example
 * ```
 * const lock = createPromiseLock()
 *
 * lock.run(async () => {
 *   await doSomething()
 * })
 *
 * // in anther context:
 * await lock.wait() // it will wait all tasking finished
 * ```
 */
declare function createPromiseLock(): {
    run<T = void>(fn: () => Promise<T>): Promise<T>;
    wait(): Promise<void>;
    isWaiting(): boolean;
    clear(): void;
};
/**
 * Promise with `resolve` and `reject` methods of itself
 */
interface ControlledPromise<T = void> extends Promise<T> {
    resolve(value: T | PromiseLike<T>): void;
    reject(reason?: any): void;
}
/**
 * Return a Promise with `resolve` and `reject` methods
 *
 * @category Promise
 * @example
 * ```
 * const promise = createControlledPromise()
 *
 * await promise
 *
 * // in anther context:
 * promise.resolve(data)
 * ```
 */
declare function createControlledPromise<T>(): ControlledPromise<T>;

/**
 * Replace backslash to slash
 *
 * @category String
 */
declare function slash(str: string): string;
/**
 * Ensure prefix of a string
 *
 * @category String
 */
declare function ensurePrefix(prefix: string, str: string): string;
/**
 * Ensure suffix of a string
 *
 * @category String
 */
declare function ensureSuffix(suffix: string, str: string): string;
/**
 * Dead simple template engine, just like Python's `.format()`
 *
 * @category String
 * @example
 * ```
 * const result = template(
 *   'Hello {0}! My name is {1}.',
 *   'John',
 *   'B.'
 * ) // Hello John! My name is B..
 * ```
 */
declare function template(str: string, ...args: any[]): string;

/**
 * Class for `setTimeout` with controls.
 * @internal
 *
 * @category Class
 */
declare class Timer {
    private timerId;
    private startedAt;
    private interval;
    /**
     * @readonly
     */
    readonly callback: CallableFunction;
    /**
     * @param cb - Callback for setTimeout
     * @param interval - delay (in millisecond)
     *
     * @beta
     */
    constructor(cb: (...args: unknown[]) => any, interval: number);
    /**
     * It stops the timer, then subtracts the time that has passed since the timer was started from the interval
     */
    pause(): void;
    /**
     * It resumes the timer by setting the startedAt property to the current time, and then setting the timerId property to
     * the result of calling setTimeout with the callback and interval properties
     */
    resume(): void;
    stop(): void;
}

/**
 * Timestamp value
 *
 * @category Time/Timer
 */
declare const timestamp: () => number;
/**
 * @param cb - Callback for setTimeout
 * @param interval - delay (in millisecond)
 *
 * @category Time/Timer
 */
declare function stoppableTimeOut(cb: (...args: unknown[]) => any, interval: number): Timer;

// Type definitions for throttle-debounce 5.0


interface CancelOptions {
    upcomingOnly?: boolean;
}

interface Cancel {
    cancel: (options?: CancelOptions) => void;
}

interface NoReturn<T extends (...args: any[]) => any> {
    (...args: Parameters<T>): void;
}

interface ThrottleOptions {
    noTrailing?: boolean;
    noLeading?: boolean;
    debounceMode?: boolean;
}

interface DebounceOptions {
    atBegin?: boolean;
}

type throttle<T extends (...args: any[]) => any> = NoReturn<T> & Cancel;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * throttled-function is executed.
 *
 * @param options
 * An object to configure options.
 *
 * @param options.noTrailing
 * Optional, defaults to false. If noTrailing is true, callback will only execute
 * every `delay` milliseconds while the throttled-function is being called. If
 * noTrailing is false or unspecified, callback will be executed one final time
 * after the last throttled-function call. (After the throttled-function has not
 * been called for `delay` milliseconds, the internal counter is reset)
 *
 * @param options.noLeading
 * Optional, defaults to false. If noLeading is false, the first throttled-function
 * call will execute callback immediately. If noLeading is true, the first the
 * callback execution will be skipped. It should be noted that callback will never
 * executed if both noLeading = true and noTrailing = true.
 *
 * @param options.debounceMode If `debounceMode` is true (at begin), schedule
 * `callback` to execute after `delay` ms. If `debounceMode` is false (at end),
 * schedule `callback` to execute after `delay` ms.
 *
 * @return
 * A new, throttled, function.
 */
declare function throttle<T extends (...args: any[]) => any>(
    delay: number,
    callback: T,
    options?: ThrottleOptions,
): throttle<T>;
type debounce<T extends (...args: any[]) => any> = NoReturn<T> & Cancel;

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * debounced-function is executed.
 *
 * @param options
 * An object to configure options.
 *
 * @param options.atBegin
 * If atBegin is false or unspecified, callback will only be executed `delay`
 * milliseconds after the last debounced-function call. If atBegin is true,
 * callback will be executed only at the first debounced-function call. (After
 * the throttled-function has not been called for `delay` milliseconds, the
 * internal counter is reset).
 *
 * @return
 * A new, debounced function.
 */
declare function debounce<T extends (...args: any[]) => any>(
    delay: number,
    callback: T,
    options?: DebounceOptions,
): debounce<T>;

declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

type StringDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

/**
Get keys of the given type as strings.

Number keys are converted to strings.

Use-cases:
- Get string keys from a type which may have number keys.
- Makes it possible to index using strings retrieved from template types.

@example
```
import type {StringKeyOf} from 'type-fest';

type Foo = {
	1: number,
	stringKey: string,
};

type StringKeysOfFoo = StringKeyOf<Foo>;
//=> '1' | 'stringKey'
```

@category Object
*/
type StringKeyOf<BaseType> = `${Extract<keyof BaseType, string | number>}`;

/**
Represents an array of strings split using a given character or character set.

Use-case: Defining the return type of a method like `String.prototype.split`.

@example
```
import type {Split} from 'type-fest';

declare function split<S extends string, D extends string>(string: S, separator: D): Split<S, D>;

type Item = 'foo' | 'bar' | 'baz' | 'waldo';
const items = 'foo,bar,baz,waldo';
let array: Item[];

array = split(items, ',');
```

@category String
@category Template literal
*/
type Split<
	S extends string,
	Delimiter extends string,
> = S extends `${infer Head}${Delimiter}${infer Tail}`
	? [Head, ...Split<Tail, Delimiter>]
	: S extends Delimiter
	? []
	: [S];

type GetOptions = {
	strict?: boolean;
};

/**
Like the `Get` type but receives an array of strings as a path parameter.
*/
type GetWithPath<BaseType, Keys extends readonly string[], Options extends GetOptions = {}> =
	Keys extends []
	? BaseType
	: Keys extends readonly [infer Head, ...infer Tail]
	? GetWithPath<
		PropertyOf<BaseType, Extract<Head, string>, Options>,
		Extract<Tail, string[]>,
		Options
	>
	: never;

/**
Adds `undefined` to `Type` if `strict` is enabled.
*/
type Strictify<Type, Options extends GetOptions> =
	Options['strict'] extends true ? Type | undefined : Type;

/**
If `Options['strict']` is `true`, includes `undefined` in the returned type when accessing properties on `Record<string, any>`.

Known limitations:
- Does not include `undefined` in the type on object types with an index signature (for example, `{a: string; [key: string]: string}`).
*/
type StrictPropertyOf<BaseType, Key extends keyof BaseType, Options extends GetOptions> =
	Record<string, any> extends BaseType
	? string extends keyof BaseType
		? Strictify<BaseType[Key], Options> // Record<string, any>
		: BaseType[Key] // Record<'a' | 'b', any> (Records with a string union as keys have required properties)
	: BaseType[Key];

/**
Splits a dot-prop style path into a tuple comprised of the properties in the path. Handles square-bracket notation.

@example
```
ToPath<'foo.bar.baz'>
//=> ['foo', 'bar', 'baz']

ToPath<'foo[0].bar.baz'>
//=> ['foo', '0', 'bar', 'baz']
```
*/
type ToPath<S extends string> = Split<FixPathSquareBrackets<S>, '.'>;

/**
Replaces square-bracketed dot notation with dots, for example, `foo[0].bar` -> `foo.0.bar`.
*/
type FixPathSquareBrackets<Path extends string> =
	Path extends `[${infer Head}]${infer Tail}`
	? Tail extends `[${string}`
		? `${Head}.${FixPathSquareBrackets<Tail>}`
		: `${Head}${FixPathSquareBrackets<Tail>}`
	: Path extends `${infer Head}[${infer Middle}]${infer Tail}`
	? `${Head}.${FixPathSquareBrackets<`[${Middle}]${Tail}`>}`
	: Path;

/**
Returns true if `LongString` is made up out of `Substring` repeated 0 or more times.

@example
```
ConsistsOnlyOf<'aaa', 'a'> //=> true
ConsistsOnlyOf<'ababab', 'ab'> //=> true
ConsistsOnlyOf<'aBa', 'a'> //=> false
ConsistsOnlyOf<'', 'a'> //=> true
```
*/
type ConsistsOnlyOf<LongString extends string, Substring extends string> =
	LongString extends ''
	? true
	: LongString extends `${Substring}${infer Tail}`
	? ConsistsOnlyOf<Tail, Substring>
	: false;

/**
Convert a type which may have number keys to one with string keys, making it possible to index using strings retrieved from template types.

@example
```
type WithNumbers = {foo: string; 0: boolean};
type WithStrings = WithStringKeys<WithNumbers>;

type WithNumbersKeys = keyof WithNumbers;
//=> 'foo' | 0
type WithStringsKeys = keyof WithStrings;
//=> 'foo' | '0'
```
*/
type WithStringKeys<BaseType> = {
	[Key in StringKeyOf<BaseType>]: UncheckedIndex<BaseType, Key>
};

/**
Perform a `T[U]` operation if `T` supports indexing.
*/
type UncheckedIndex<T, U extends string | number> = [T] extends [Record<string | number, any>] ? T[U] : never;

/**
Get a property of an object or array. Works when indexing arrays using number-literal-strings, for example, `PropertyOf<number[], '0'> = number`, and when indexing objects with number keys.

Note:
- Returns `unknown` if `Key` is not a property of `BaseType`, since TypeScript uses structural typing, and it cannot be guaranteed that extra properties unknown to the type system will exist at runtime.
- Returns `undefined` from nullish values, to match the behaviour of most deep-key libraries like `lodash`, `dot-prop`, etc.
*/
type PropertyOf<BaseType, Key extends string, Options extends GetOptions = {}> =
	BaseType extends null | undefined
	? undefined
	: Key extends keyof BaseType
	? StrictPropertyOf<BaseType, Key, Options>
	: BaseType extends [] | [unknown, ...unknown[]]
	? unknown // It's a tuple, but `Key` did not extend `keyof BaseType`. So the index is out of bounds.
	: BaseType extends {
		[n: number]: infer Item;
		length: number; // Note: This is needed to avoid being too lax with records types using number keys like `{0: string; 1: boolean}`.
	}
	? (
		ConsistsOnlyOf<Key, StringDigit> extends true
		? Strictify<Item, Options>
		: unknown
	)
	: Key extends keyof WithStringKeys<BaseType>
	? StrictPropertyOf<WithStringKeys<BaseType>, Key, Options>
	: unknown;

// This works by first splitting the path based on `.` and `[...]` characters into a tuple of string keys. Then it recursively uses the head key to get the next property of the current object, until there are no keys left. Number keys extract the item type from arrays, or are converted to strings to extract types from tuples and dictionaries with number keys.
/**
Get a deeply-nested property from an object using a key path, like Lodash's `.get()` function.

Use-case: Retrieve a property from deep inside an API response or some other complex object.

@example
```
import type {Get} from 'type-fest';
import * as lodash from 'lodash';

const get = <BaseType, Path extends string | readonly string[]>(object: BaseType, path: Path): Get<BaseType, Path> =>
	lodash.get(object, path);

interface ApiResponse {
	hits: {
		hits: Array<{
			_id: string
			_source: {
				name: Array<{
					given: string[]
					family: string
				}>
				birthDate: string
			}
		}>
	}
}

const getName = (apiResponse: ApiResponse) =>
	get(apiResponse, 'hits.hits[0]._source.name');
	//=> Array<{given: string[]; family: string}>

// Path also supports a readonly array of strings
const getNameWithPathArray = (apiResponse: ApiResponse) =>
	get(apiResponse, ['hits','hits', '0', '_source', 'name'] as const);
	//=> Array<{given: string[]; family: string}>

// Strict mode:
Get<string[], '3', {strict: true}> //=> string | undefined
Get<Record<string, string>, 'foo', {strict: true}> // => string | undefined
```

@category Object
@category Array
@category Template literal
*/
type Get<BaseType, Path extends string | readonly string[], Options extends GetOptions = {}> =
	GetWithPath<BaseType, Path extends string ? ToPath<Path> : Path, Options>;

/**
Get the value of the property at the given path.

@param object - Object or array to get the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@param defaultValue - Default value.

@example
```
import {getProperty} from 'dot-prop';

getProperty({foo: {bar: 'unicorn'}}, 'foo.bar');
//=> 'unicorn'

getProperty({foo: {bar: 'a'}}, 'foo.notDefined.deep');
//=> undefined

getProperty({foo: {bar: 'a'}}, 'foo.notDefined.deep', 'default value');
//=> 'default value'

getProperty({foo: {'dot.dot': 'unicorn'}}, 'foo.dot\\.dot');
//=> 'unicorn'

getProperty({foo: [{bar: 'unicorn'}]}, 'foo[0].bar');
//=> 'unicorn'
```
*/
declare function getProperty<ObjectType, PathType extends string, DefaultValue = undefined>(
	object: ObjectType,
	path: PathType,
	defaultValue?: DefaultValue
): ObjectType extends Record<string, unknown> | unknown[] ? (unknown extends Get<ObjectType, PathType> ? DefaultValue : Get<ObjectType, PathType>) : undefined;

/**
Set the property at the given path to the given value.

@param object - Object or array to set the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@param value - Value to set at `path`.
@returns The object.

@example
```
import {setProperty} from 'dot-prop';

const object = {foo: {bar: 'a'}};
setProperty(object, 'foo.bar', 'b');
console.log(object);
//=> {foo: {bar: 'b'}}

const foo = setProperty({}, 'foo.bar', 'c');
console.log(foo);
//=> {foo: {bar: 'c'}}

setProperty(object, 'foo.baz', 'x');
console.log(object);
//=> {foo: {bar: 'b', baz: 'x'}}

setProperty(object, 'foo.biz[0]', 'a');
console.log(object);
//=> {foo: {bar: 'b', baz: 'x', biz: ['a']}}
```
*/
declare function setProperty<ObjectType extends Record<string, any>>(
	object: ObjectType,
	path: string,
	value: unknown
): ObjectType;

/**
Check whether the property at the given path exists.

@param object - Object or array to test the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.

@example
```
import {hasProperty} from 'dot-prop';

hasProperty({foo: {bar: 'unicorn'}}, 'foo.bar');
//=> true
```
*/
declare function hasProperty(object: Record<string, any> | undefined, path: string): boolean;

/**
Delete the property at the given path.

@param object - Object or array to delete the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@returns A boolean of whether the property existed before being deleted.

@example
```
import {deleteProperty} from 'dot-prop';

const object = {foo: {bar: 'a'}};
deleteProperty(object, 'foo.bar');
console.log(object);
//=> {foo: {}}

object.foo.bar = {x: 'y', y: 'x'};
deleteProperty(object, 'foo.bar.x');
console.log(object);
//=> {foo: {bar: {y: 'x'}}}
```
*/
declare function deleteProperty(object: Record<string, any>, path: string): boolean;

export { ControlledPromise, Emitter, EventType, Handler, PartitionFilter, SingletonPromiseReturn, assert, at, batchInvoke, clamp, clampArrayRange, clearUndefined, createControlledPromise, createPromiseLock, createSingletonPromise, debounce, deepMerge, deleteProperty as deleteObjProp, ensurePrefix, ensureSuffix, flattenArrayable, getProperty as getObjProp, hasConsole, hasProperty as hasObjProp, hasOwnProperty, invoke, isArray, isBoolean, isBrowser, isDef, isFunction, isKeyOf, isNumber, isNumberish, isObject, isString, isTruthy, isWindow, last, mergeArrayable, move, noNull, noop, notNullish, notUndefined, objectEntries, objectKeys, objectMap, objectPick, partition, range, remove, sample, setProperty as setObjProp, shuffle, slash, sleep, stoppableTimeOut, sum, tap, template, throttle, timestamp, toArray, toString, uniq };
