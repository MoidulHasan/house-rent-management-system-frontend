import * as vue_demi from 'vue-demi';
import { PropType, Prop as Prop$1, VNode, StyleValue } from 'vue-demi';
import { Nullable, Numberish } from '@whoj/utils-types';

declare type VuePropType<T> = PropType<T> | true | null;
declare type DefaultFactory<T> = (props: Record<string, unknown> | T) => T | null | undefined;
declare type DefaultType<T> = T | DefaultFactory<T> | null | undefined | object;
declare type RequiredProp<T, D> = Prop$1<T, D> & {
    required: true;
};
declare type PropOptions<T, D> = Prop$1<T, D> & {
    def(value: D): PropOptions<T, D>;
    valid(validator: (value: D) => boolean): PropOptions<T, D>;
    get isRequired(): RequiredProp<T, D>;
};
declare type LiteralPropOptions<T> = Prop$1<T, T> & {
    def(value: T): LiteralPropOptions<T>;
    valid(validator: (value: T) => boolean): LiteralPropOptions<T>;
    get isRequired(): RequiredProp<T, T>;
};
declare class PropFactory<T = any, D = T> {
    type?: VuePropType<T>;
    required?: boolean;
    default?: DefaultType<D>;
    validator?(value: D): boolean;
    /**
     * The constructor function takes a type parameter T, and returns a new instance of the VuePropType class, with a type
     * property set to the type parameter T
     * @param type - VuePropType<T>
     */
    constructor(type: VuePropType<T>);
    /**
     * If the value is not undefined, set the default value to the value, and return the options object.
     * @param {D} [value] - The value of the prop.
     * @returns The PropOptions<T, D> object.
     */
    def(value?: D): PropOptions<T, D>;
    /**
     * This function takes a validator function as an argument and sets the validator property of the PropOptions object to
     * the validator function.
     * @param validator - (value: D) => boolean
     * @returns The PropOptions object.
     */
    valid(validator: (value: D) => boolean): PropOptions<T, D>;
    /**
     * It returns the current instance of the class.
     * @returns The prop itself, but with the required flag set to true.
     */
    get isRequired(): RequiredProp<T, D>;
}
/**
 * It takes a VuePropType and returns a PropOptions
 * @param type - VuePropType<T>
 * @returns A function that takes a type and returns a PropOptions<T, D>
 */
declare function defineProp<T, D = T>(type: VuePropType<T>): PropOptions<T, D>;
/**
 * `literalType` is a function that takes a generic type `T` and returns a `LiteralPropOptions<T>` object
 * @returns A function that takes a type and returns a LiteralPropOptions<T>
 */
declare function literalType<T>(): LiteralPropOptions<T>;

declare class Prop {
    static get string(): PropOptions<string, string>;
    static get number(): PropOptions<number, number>;
    static get stringNumber(): PropOptions<string | number, string | number>;
    static get boolean(): PropOptions<boolean, boolean>;
    static get symbol(): PropOptions<symbol, symbol>;
    static get date(): PropOptions<Date, Date>;
    static get vNode(): PropOptions<string | VNode<vue_demi.RendererNode, vue_demi.RendererElement, {
        [key: string]: any;
    }> | null, string | VNode<vue_demi.RendererNode, vue_demi.RendererElement, {
        [key: string]: any;
    }> | null>;
    static get css(): PropOptions<StyleValue, StyleValue>;
    static object<T = Record<string, any>>(): PropOptions<T, T>;
    static array<T = Record<string, any>>(): PropOptions<T[], T[]>;
    static function<T = () => void>(): {
        type: PropType<T>;
    };
    static boolOpt(def?: boolean): PropOptions<Nullable<boolean>, Nullable<boolean>>;
    static numberOpt(def?: number): PropOptions<Nullable<number>, Nullable<number>>;
    static stringOpt(def?: string): PropOptions<Nullable<string>, Nullable<string>>;
    static numberishOpt(def?: Numberish): PropOptions<Nullable<Numberish>, Nullable<Numberish>>;
}

export { DefaultFactory as D, LiteralPropOptions as L, PropFactory as P, RequiredProp as R, VuePropType as V, Prop as a, DefaultType as b, PropOptions as c, defineProp as d, literalType as l };
