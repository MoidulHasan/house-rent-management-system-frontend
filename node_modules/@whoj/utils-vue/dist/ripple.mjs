import { isVue3 } from 'vue-demi';
import { objectKeys, isNumber } from '@whoj/utils-core';

function setProps(modifiers, props) {
  modifiers.forEach((item) => {
    if (!isNumber(item))
      props.event = item;
    else
      props.transition = item;
  });
}
function rippleHandler(el, modifiers, options) {
  const props = {
    event: "mousedown",
    transition: 600
  };
  setProps(objectKeys(modifiers), props);
  el.addEventListener(props.event, (event) => {
    rippleEl(event, el);
  });
  const bg = (options == null ? void 0 : options.color) || "rgba(0, 0, 0, 0.35)";
  const zIndex = (options == null ? void 0 : options.zIndex) || "9999";
  const rippleEl = function(event, el2) {
    const target = el2;
    const targetBorder = parseInt(getComputedStyle(target).borderWidth.replace("px", ""));
    const clientX = event.clientX || event.touches[0].clientX;
    const clientY = event.clientY || event.touches[0].clientY;
    const rect = target.getBoundingClientRect();
    const left = rect.left;
    const top = rect.top;
    const width = target.offsetWidth;
    const height = target.offsetHeight;
    const dx = clientX - left;
    const dy = clientY - top;
    const maxX = Math.max(dx, width - dx);
    const maxY = Math.max(dy, height - dy);
    const style = window.getComputedStyle(target);
    const radius = Math.sqrt(maxX * maxX + maxY * maxY);
    const border = targetBorder > 0 ? targetBorder : 0;
    const ripple = document.createElement("div");
    const rippleContainer = document.createElement("div");
    rippleContainer.className = "ripple-container";
    ripple.className = "ripple";
    ripple.style.marginTop = "0px";
    ripple.style.marginLeft = "0px";
    ripple.style.width = "1px";
    ripple.style.height = "1px";
    ripple.style.transition = `all ${props.transition}ms cubic-bezier(0.4, 0, 0.2, 1)`;
    ripple.style.borderRadius = "50%";
    ripple.style.pointerEvents = "none";
    ripple.style.position = "relative";
    ripple.style.zIndex = zIndex;
    ripple.style.backgroundColor = bg;
    rippleContainer.style.position = "absolute";
    rippleContainer.style.left = `${0 - border}px`;
    rippleContainer.style.top = `${0 - border}px`;
    rippleContainer.style.height = "0";
    rippleContainer.style.width = "0";
    rippleContainer.style.pointerEvents = "none";
    rippleContainer.style.overflow = "hidden";
    const storedTargetPosition = target.style.position.length > 0 ? target.style.position : getComputedStyle(target).position;
    if (storedTargetPosition !== "relative")
      target.style.position = "relative";
    rippleContainer.appendChild(ripple);
    target.appendChild(rippleContainer);
    ripple.style.marginLeft = `${dx}px`;
    ripple.style.marginTop = `${dy}px`;
    rippleContainer.style.width = `${width}px`;
    rippleContainer.style.height = `${height}px`;
    rippleContainer.style.borderTopLeftRadius = style.borderTopLeftRadius;
    rippleContainer.style.borderTopRightRadius = style.borderTopRightRadius;
    rippleContainer.style.borderBottomLeftRadius = style.borderBottomLeftRadius;
    rippleContainer.style.borderBottomRightRadius = style.borderBottomRightRadius;
    rippleContainer.style.direction = "ltr";
    setTimeout(() => {
      ripple.style.width = `${radius * 2}px`;
      ripple.style.height = `${radius * 2}px`;
      ripple.style.marginLeft = `${dx - radius}px`;
      ripple.style.marginTop = `${dy - radius}px`;
    }, 0);
    function clearRipple() {
      setTimeout(() => {
        ripple.style.backgroundColor = "rgba(0, 0, 0, 0)";
      }, 250);
      setTimeout(() => {
        var _a;
        (_a = rippleContainer.parentNode) == null ? void 0 : _a.removeChild(rippleContainer);
      }, 850);
      el2.removeEventListener("mouseup", clearRipple, false);
      el2.removeEventListener("mouseleave", clearRipple, false);
      el2.removeEventListener("dragstart", clearRipple, false);
      setTimeout(() => {
        let clearPosition = true;
        for (const child of target.childNodes) {
          if (child.className === "ripple-container")
            clearPosition = false;
        }
        if (clearPosition) {
          if (storedTargetPosition !== "static")
            target.style.position = storedTargetPosition;
          else
            target.style.position = "";
        }
      }, props.transition + 250);
    }
    if (event.type === "mousedown") {
      el2.addEventListener("mouseup", clearRipple, false);
      el2.addEventListener("mouseleave", clearRipple, false);
      el2.addEventListener("dragstart", clearRipple, false);
    } else {
      clearRipple();
    }
  };
}
function makeRippleDir(options = {}) {
  return {
    [`${isVue3 ? "beforeMount" : "bind"}`]: (el, binding) => rippleHandler(
      el,
      binding.modifiers,
      { ...options, color: binding.value }
    )
  };
}
const vRipple = makeRippleDir();
function useRipple(el, event, options) {
  const element = el instanceof HTMLElement ? el : el.value;
  rippleHandler(element, event ? { [event]: true } : { mousedown: true }, options);
}
const Ripple = {
  install(app, options) {
    app.directive("ripple", makeRippleDir(options));
  }
};

export { Ripple, useRipple, vRipple };
